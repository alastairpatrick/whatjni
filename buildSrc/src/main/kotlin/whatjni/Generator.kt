package whatjni

import ClassMap
import ClassModel
import FieldModel
import MethodModel
import org.objectweb.asm.*
import java.io.BufferedWriter
import java.io.File
import java.io.FileWriter
import java.io.Writer

class Generator(val generatedDir: File, val classMap: ClassMap): ClassVisitor(Opcodes.ASM7) {
    lateinit var classModel: ClassModel
    lateinit var writer: Writer

    override fun visit(
        version: Int,
        access: Int,
        unescapedName: String,
        signature: String?,
        superName: String?,
        interfaceNames: Array<out String>
    ) {
        val superClass = if (superName != null) classMap.get(superName) else null
        val interfaces = interfaceNames.map { classMap.get(it) }

        classModel = ClassModel(access, unescapedName, signature, superClass, interfaces)
    }

    override fun visitField(
        access: Int,
        unescapedName: String,
        descriptor: String,
        signature: String?,
        value: Any?
    ): FieldVisitor? {
        val field = FieldModel(access, unescapedName, descriptor, signature, value)
        classModel.fields.add(field)
        return null
    }

    override fun visitMethod(
        access: Int,
        unescapedName: String,
        descriptor: String,
        signature: String?,
        exceptions: Array<out String>?
    ): MethodVisitor? {
        // Skip bridge methods generated by compiler
        if ((access and Opcodes.ACC_BRIDGE) != 0) {
            return null
        }

        if ((access and Opcodes.ACC_NATIVE) == 0) {
            // Skip method overrides unless native
            var baseClass = classModel.superClass
            while (baseClass != null) {
                if (baseClass.methods.containsKey(Pair(unescapedName, descriptor))) {
                    return null
                }
                baseClass = baseClass.superClass
            }
        } else {
            // Can skip private members if no natives
            classModel.hasNativeMethods = true
        }

        val method = MethodModel(access, unescapedName, descriptor, signature)
        classModel.methods[Pair(method.unescapedName, method.descriptor)] = method
        return null
    }

    override fun visitEnd() {
        val generatedFile = generatedDir.resolve(classModel.unescapedName + ".class.h")
        generatedFile.parentFile.mkdirs()
        BufferedWriter(FileWriter(generatedFile)).use {
            writer = it
            generate()
        }
    }

    fun generate() {
        writeHeader()
        writeForwardDeclarations()
        writeOpenNamespace()
        writeFieldClass()
        writeMethodClass()
        writeCloseNamespace()
        writeFooter()
    }

    fun writeHeader() {
        writer.write("""
            // Don't edit; automatically generated.
                        
            #ifndef ${classModel.sentryMacro}
            #define ${classModel.sentryMacro}
             
            #include "whatjni/array.h"
            #include "whatjni/ref.h"
            
            """.trimIndent())

        val superClass = classModel.superClass
        if (superClass != null) {
            writer.write("#include \"${superClass.unescapedName}.class.h\"")
        }

        writer.write("\n\n")
    }

    fun writeForwardDeclarations() {
        val declared = HashSet<String>()

        fun declareClass(unescapedName: String): Boolean {
            if (declared.add(unescapedName)) {
                val name = escapeQualifiedName(unescapedName)

                val parts = name.split(".")
                for (i in 0..parts.size - 2) {
                    writer.write("namespace ${parts[i]} { ")
                }
                writer.write("class ${parts[parts.size - 1]}; ")
                for (i in 0..parts.size - 2) {
                    writer.write("} ")
                }
                writer.write("\n")

                return true
            }
            return false
        }

        fun recurseType(type: Type) {
            when (type.sort) {
                Type.OBJECT -> declareClass(type.className)
                Type.ARRAY -> recurseType(type.elementType)
                Type.METHOD -> {
                    recurseType(type.returnType)
                    for (argType in type.argumentTypes) {
                        recurseType(argType)
                    }
                }
            }
        }

        val todo = arrayListOf(classModel)
        while (!todo.isEmpty()) {
            val model = todo.removeLast()
            if (declareClass(model.unescapedName.replace("/", "."))) {
                for (iface in model.interfaces) {
                    todo.add(iface)
                }
            }
        }

        for (field in classModel.fields) {
            recurseType(field.type)
        }

        for ((_, method) in classModel.methods) {
            recurseType(method.type.returnType)
            for (argType in method.type.argumentTypes) {
                recurseType(argType)
            }
        }

        writer.write("\n")
    }

    fun writeOpenNamespace() {
        val nameParts = classModel.nameParts
        for (i in 0 .. nameParts.size - 2) {
            writer.write("namespace ${nameParts[i]} {\n")
        }
    }

    fun writeFieldClass() {
        val nameParts = classModel.nameParts
        writer.write("\nclass var_${nameParts[nameParts.size - 1]}")

        val superClass = classModel.superClass
        if (superClass != null) {
            writer.write(": public " + superClass.escapedName)
        }

        writer.write(" {\n")

        for (field in classModel.fields) {
            writeField(field)
        }

        writer.write("};\n\n")
    }

    fun writeField(field: FieldModel) {
        field.apply {
            if (!classModel.hasNativeMethods && ((access and Opcodes.ACC_PRIVATE) != 0)) {
                return
            }

            val cppType = makeCPPType(type, false)
            val paramCPPType = makeCPPType(type, true)
            val escapedName = escapeSimpleName(unescapedName)
            val modifiers = getModifiers(access)

            var getFieldID = "whatjni::get_field_id"
            var getField = "whatjni::get_field"
            var setField = "whatjni::set_field"
            var target = "(jobject) this"
            if ((access and Opcodes.ACC_STATIC) != 0) {
                getFieldID = "whatjni::get_static_field_id"
                getField = "whatjni::get_static_field"
                setField = "whatjni::set_static_field"
                target = "clazz"
            }

            writeAccess(access)

            if (value != null) {
                writer.write(
                    """
                    const static $cppType $escapedName = $value;
                    """.replaceIndent("    ")
                )
            } else {
                writer.write(
                    """
                    $modifiers$cppType get_$escapedName() {
                        static jclass clazz = whatjni::find_class("${classModel.unescapedName}");
                        static jfieldID field = $getFieldID(clazz, "$unescapedName", "$descriptor");

                    """.replaceIndent("    ")
                )

                when (type.sort) {
                    Type.OBJECT, Type.ARRAY -> writer.write("        return $cppType($getField<jobject>($target, field), whatjni::own_ref);\n")
                    else ->                    writer.write("        return $getField<$cppType>($target, field);\n")
                }

                writer.write("    }\n")

                if ((access and Opcodes.ACC_FINAL) == 0) {
                    writer.write(
                        """
                            ${modifiers}void set_$escapedName($paramCPPType value) {
                                static jclass clazz = whatjni::find_class("${classModel.unescapedName}");
                                static jfieldID field = $getFieldID(clazz, "$unescapedName", "$descriptor");
                            
                        """.replaceIndent("    ")
                    )

                    when (type.sort) {
                        Type.OBJECT, Type.ARRAY -> writer.write("        $setField($target, field, (jobject) value.operator->());\n")
                        else ->                    writer.write("        $setField($target, field, value);\n")
                    }

                    writer.write("    }\n")

                    if ((access and Opcodes.ACC_STATIC) == 0) {
                        writer.write("    WHATJNI_IF_PROPERTY(__declspec(property(get=get_$escapedName, put=set_$escapedName)) $modifiers$cppType $escapedName;)\n")
                    }
                } else {
                    if ((access and Opcodes.ACC_STATIC) == 0) {
                        writer.write("    WHATJNI_IF_PROPERTY(__declspec(property(get=get_$escapedName)) $modifiers$cppType $escapedName;)\n")
                    }
                }
            }

            writer.write("\n")
        }
    }

    fun writeMethodClass() {
        val nameParts = classModel.nameParts
        val unqualifiedClassName = nameParts[nameParts.size - 1]
        writer.write("""
                     class $unqualifiedClassName: public var_$unqualifiedClassName {
                     public:
                        typedef var_$unqualifiedClassName var;
                        
                     """.trimIndent())

        val superClass = classModel.superClass
        if (superClass != null) {
            writeStaticAssign(superClass)
        }
        val assigns = HashSet<ClassModel>()
        val todo = arrayListOf(classModel)
        while (!todo.isEmpty()) {
            val classModel = todo.removeLast()
            for (iface in classModel.interfaces) {
                if (assigns.add(iface)) {
                    todo.add(iface)
                }
            }
            writeStaticAssign(classModel)
        }

        for ((_, method) in classModel.methods) {
            writeMethod(method)
        }

        writer.write("};\n\n")
    }

    fun writeStaticAssign(assignToModel: ClassModel) {
        writer.write("    static void static_assert_assignable(${assignToModel.escapedName}*) {}\n")
    }

    fun writeMethod(method: MethodModel) {
        method.apply {
            if (!classModel.hasNativeMethods && ((access and Opcodes.ACC_PRIVATE) != 0)) {
                return
            }

            val type = Type.getMethodType(descriptor)
            val cppReturnType = makeCPPType(type.returnType, false)
            val escapedName = escapeSimpleName(unescapedName)
            val modifiers = getModifiers(access)

            var getMethodID = "whatjni::get_method_id"
            var callMethod = "whatjni::call_method"
            var target = "(jobject) this"
            if ((access and Opcodes.ACC_STATIC) != 0) {
                getMethodID = "whatjni::get_static_method_id"
                callMethod = "whatjni::call_static_method"
                target = "clazz"
            }
            writeAccess(access)

            writer.write("    ${modifiers}$cppReturnType ${escapedName}(")
            var i = 0
            for (argumentType in type.argumentTypes) {
                val cppArgumentTypeName = makeCPPType(argumentType, true)
                if (i > 0) {
                    writer.write(", ")
                }
                writer.write("$cppArgumentTypeName a$i")
                ++i
            }
            writer.write(") {\n")

            writer.write(
                """
                static jclass clazz = whatjni::find_class("${classModel.unescapedName}");
                static jmethodID method = $getMethodID(clazz, "$unescapedName", "$descriptor");
                return """.replaceIndent("        ")
            )

            when (type.returnType.sort) {
                Type.OBJECT, Type.ARRAY -> writer.write("$cppReturnType($callMethod<jobject>($target, method")
                else -> writer.write("$callMethod<$cppReturnType>($target, method")
            }

            i = 0
            for (argumentType in type.argumentTypes) {
                writer.write(", ")
                when (argumentType.sort) {
                    Type.OBJECT, Type.ARRAY -> writer.write("(jobject) a$i.operator->()")
                    else -> writer.write("a$i")
                }
                ++i
            }

            when (type.returnType.sort) {
                Type.OBJECT, Type.ARRAY -> writer.write("), whatjni::own_ref);\n")
                else -> writer.write(");\n")
            }

            writer.write("    }\n\n")
        }
    }

    private fun writeAccess(access: Int) {
        if ((access and Opcodes.ACC_PUBLIC) != 0) {
            writer.write("public:\n")
        } else if ((access and Opcodes.ACC_PROTECTED) != 0) {
            writer.write("protected:\n")
        } else if ((access and Opcodes.ACC_PRIVATE) != 0) {
            writer.write("private:\n")
        } else {
            writer.write("public:\n")
        }
    }

    fun writeCloseNamespace() {
        val nameParts = classModel.nameParts
        for (i in nameParts.size - 2 downTo 0) {
            writer.write("}  // namespace ${nameParts[i]}\n")
        }
    }

    fun writeFooter() {
        writer.write("\n\n#endif  // ${classModel.sentryMacro}\n")
    }

    private fun getModifiers(access: Int): String {
        var result = ""
        if ((access and Opcodes.ACC_STATIC) != 0) {
            result += "static "
        }
        return result
    }

    private fun makeCPPType(type: Type, param: Boolean): String {
        var result = when (type.sort) {
            Type.VOID -> "void"
            Type.BOOLEAN -> "jboolean"
            Type.BYTE -> "jbyte"
            Type.SHORT -> "jshort"
            Type.INT -> "jint"
            Type.LONG -> "jlong"
            Type.CHAR -> "jchar"
            Type.FLOAT -> "jfloat"
            Type.DOUBLE -> "jdouble"
            Type.OBJECT -> "whatjni::ref<${escapeQualifiedName(type.className).replace(".", "::")}>"
            Type.ARRAY -> "whatjni::ref<whatjni::array< " + makeCPPType(type.elementType, false) + " >>"
            else -> "void"
        }

        if (param && (type.sort == Type.OBJECT || type.sort == Type.ARRAY)) {
            result = "const ${result}&"
        }

        return result
    }
}